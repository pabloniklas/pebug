# Generated from /Users/ttys9/PycharmProjects/pebug/grammar/asm8086.g4 by ANTLR 4.9.2
# encoding: utf-8
import sys
from io import StringIO

from antlr4 import *

if sys.version_info[1] > 5:
    from typing import TextIO
else:
    from typing.io import TextIO


def serializedATN():
    with StringIO() as buf:
        buf.write("\3\u608b\ua72a\u8133\ub9ed\u417c\u3be7\u7786\u5964\3\61")
        buf.write("\u0124\4\2\t\2\4\3\t\3\4\4\t\4\4\5\t\5\4\6\t\6\4\7\t\7")
        buf.write("\4\b\t\b\4\t\t\t\4\n\t\n\4\13\t\13\4\f\t\f\4\r\t\r\4\16")
        buf.write("\t\16\4\17\t\17\4\20\t\20\4\21\t\21\4\22\t\22\4\23\t\23")
        buf.write("\4\24\t\24\4\25\t\25\4\26\t\26\4\27\t\27\4\30\t\30\4\31")
        buf.write("\t\31\4\32\t\32\4\33\t\33\4\34\t\34\4\35\t\35\4\36\t\36")
        buf.write("\4\37\t\37\4 \t \4!\t!\4\"\t\"\4#\t#\4$\t$\4%\t%\4&\t")
        buf.write("&\3\2\3\2\3\2\7\2P\n\2\f\2\16\2S\13\2\3\2\3\2\7\2W\n\2")
        buf.write("\f\2\16\2Z\13\2\3\3\5\3]\n\3\3\3\3\3\5\3a\n\3\3\3\5\3")
        buf.write("d\n\3\3\4\5\4g\n\4\3\4\3\4\5\4k\n\4\3\5\3\5\5\5o\n\5\3")
        buf.write("\6\3\6\3\6\3\6\3\6\3\6\3\6\3\6\3\6\3\6\3\6\3\6\3\6\3\6")
        buf.write("\3\6\3\6\5\6\u0081\n\6\3\7\5\7\u0084\n\7\3\7\3\7\3\7\3")
        buf.write("\b\5\b\u008a\n\b\3\b\3\b\3\b\3\t\5\t\u0090\n\t\3\t\3\t")
        buf.write("\3\t\3\n\3\n\5\n\u0097\n\n\3\13\3\13\5\13\u009b\n\13\3")
        buf.write("\f\3\f\3\f\3\r\3\r\3\r\3\16\3\16\3\16\3\17\3\17\3\17\3")
        buf.write("\17\3\20\3\20\3\20\3\21\3\21\3\21\3\21\7\21\u00b1\n\21")
        buf.write("\f\21\16\21\u00b4\13\21\3\21\3\21\3\21\3\21\5\21\u00ba")
        buf.write("\n\21\3\22\3\22\3\23\3\23\3\23\3\23\5\23\u00c2\n\23\3")
        buf.write("\24\3\24\3\25\3\25\3\26\3\26\3\26\3\27\3\27\3\27\3\30")
        buf.write("\3\30\3\30\3\31\3\31\3\31\7\31\u00d4\n\31\f\31\16\31\u00d7")
        buf.write("\13\31\3\32\3\32\3\33\3\33\3\33\7\33\u00de\n\33\f\33\16")
        buf.write("\33\u00e1\13\33\3\34\3\34\3\34\7\34\u00e6\n\34\f\34\16")
        buf.write("\34\u00e9\13\34\3\35\3\35\3\35\3\35\3\35\3\35\3\35\3\35")
        buf.write("\3\35\3\35\3\35\5\35\u00f6\n\35\3\35\3\35\3\35\3\35\3")
        buf.write("\35\3\35\3\35\3\35\3\35\3\35\3\35\3\35\3\35\3\35\3\35")
        buf.write("\3\35\3\35\3\35\5\35\u010a\n\35\3\36\5\36\u010d\n\36\3")
        buf.write("\36\3\36\3\37\3\37\3 \3 \3!\3!\3\"\3\"\3#\5#\u011a\n#")
        buf.write("\3#\3#\3$\3$\3%\3%\3&\3&\3&\2\2\'\2\4\6\b\n\f\16\20\22")
        buf.write("\24\26\30\32\34\36 \"$&(*,.\60\62\64\668:<>@BDFHJ\2\5")
        buf.write("\3\2\b\t\3\2\13\16\3\2\21\23\2\u0131\2X\3\2\2\2\4\\\3")
        buf.write("\2\2\2\6f\3\2\2\2\bl\3\2\2\2\n\u0080\3\2\2\2\f\u0083\3")
        buf.write("\2\2\2\16\u0089\3\2\2\2\20\u008f\3\2\2\2\22\u0094\3\2")
        buf.write("\2\2\24\u0098\3\2\2\2\26\u009c\3\2\2\2\30\u009f\3\2\2")
        buf.write("\2\32\u00a2\3\2\2\2\34\u00a5\3\2\2\2\36\u00a9\3\2\2\2")
        buf.write(" \u00b9\3\2\2\2\"\u00bb\3\2\2\2$\u00c1\3\2\2\2&\u00c3")
        buf.write("\3\2\2\2(\u00c5\3\2\2\2*\u00c7\3\2\2\2,\u00ca\3\2\2\2")
        buf.write(".\u00cd\3\2\2\2\60\u00d0\3\2\2\2\62\u00d8\3\2\2\2\64\u00da")
        buf.write("\3\2\2\2\66\u00e2\3\2\2\28\u0109\3\2\2\2:\u010c\3\2\2")
        buf.write("\2<\u0110\3\2\2\2>\u0112\3\2\2\2@\u0114\3\2\2\2B\u0116")
        buf.write("\3\2\2\2D\u0119\3\2\2\2F\u011d\3\2\2\2H\u011f\3\2\2\2")
        buf.write("J\u0121\3\2\2\2LQ\5\4\3\2MN\7\3\2\2NP\5\4\3\2OM\3\2\2")
        buf.write("\2PS\3\2\2\2QO\3\2\2\2QR\3\2\2\2RT\3\2\2\2SQ\3\2\2\2T")
        buf.write("U\7\60\2\2UW\3\2\2\2VL\3\2\2\2WZ\3\2\2\2XV\3\2\2\2XY\3")
        buf.write("\2\2\2Y\3\3\2\2\2ZX\3\2\2\2[]\5\b\5\2\\[\3\2\2\2\\]\3")
        buf.write("\2\2\2]`\3\2\2\2^a\5\n\6\2_a\5\6\4\2`^\3\2\2\2`_\3\2\2")
        buf.write("\2`a\3\2\2\2ac\3\2\2\2bd\5J&\2cb\3\2\2\2cd\3\2\2\2d\5")
        buf.write("\3\2\2\2eg\5H%\2fe\3\2\2\2fg\3\2\2\2gh\3\2\2\2hj\5F$\2")
        buf.write("ik\5\60\31\2ji\3\2\2\2jk\3\2\2\2k\7\3\2\2\2ln\5\62\32")
        buf.write("\2mo\7\4\2\2nm\3\2\2\2no\3\2\2\2o\t\3\2\2\2p\u0081\5*")
        buf.write("\26\2q\u0081\5(\25\2r\u0081\5\36\20\2s\u0081\5&\24\2t")
        buf.write("\u0081\5\34\17\2u\u0081\5\30\r\2v\u0081\5\26\f\2w\u0081")
        buf.write("\5\22\n\2x\u0081\5\32\16\2y\u0081\5\24\13\2z\u0081\5,")
        buf.write("\27\2{\u0081\5.\30\2|\u0081\5\f\7\2}\u0081\5\16\b\2~\u0081")
        buf.write("\5\20\t\2\177\u0081\7\5\2\2\u0080p\3\2\2\2\u0080q\3\2")
        buf.write("\2\2\u0080r\3\2\2\2\u0080s\3\2\2\2\u0080t\3\2\2\2\u0080")
        buf.write("u\3\2\2\2\u0080v\3\2\2\2\u0080w\3\2\2\2\u0080x\3\2\2\2")
        buf.write("\u0080y\3\2\2\2\u0080z\3\2\2\2\u0080{\3\2\2\2\u0080|\3")
        buf.write("\2\2\2\u0080}\3\2\2\2\u0080~\3\2\2\2\u0080\177\3\2\2\2")
        buf.write("\u0081\13\3\2\2\2\u0082\u0084\5B\"\2\u0083\u0082\3\2\2")
        buf.write("\2\u0083\u0084\3\2\2\2\u0084\u0085\3\2\2\2\u0085\u0086")
        buf.write("\7#\2\2\u0086\u0087\5\64\33\2\u0087\r\3\2\2\2\u0088\u008a")
        buf.write("\5B\"\2\u0089\u0088\3\2\2\2\u0089\u008a\3\2\2\2\u008a")
        buf.write("\u008b\3\2\2\2\u008b\u008c\7$\2\2\u008c\u008d\5\64\33")
        buf.write("\2\u008d\17\3\2\2\2\u008e\u0090\5B\"\2\u008f\u008e\3\2")
        buf.write("\2\2\u008f\u0090\3\2\2\2\u0090\u0091\3\2\2\2\u0091\u0092")
        buf.write("\7%\2\2\u0092\u0093\5\64\33\2\u0093\21\3\2\2\2\u0094\u0096")
        buf.write("\7\25\2\2\u0095\u0097\5\64\33\2\u0096\u0095\3\2\2\2\u0096")
        buf.write("\u0097\3\2\2\2\u0097\23\3\2\2\2\u0098\u009a\7\24\2\2\u0099")
        buf.write("\u009b\5\64\33\2\u009a\u0099\3\2\2\2\u009a\u009b\3\2\2")
        buf.write("\2\u009b\25\3\2\2\2\u009c\u009d\7\35\2\2\u009d\u009e\5")
        buf.write("\60\31\2\u009e\27\3\2\2\2\u009f\u00a0\7\36\2\2\u00a0\u00a1")
        buf.write("\5\60\31\2\u00a1\31\3\2\2\2\u00a2\u00a3\7\37\2\2\u00a3")
        buf.write("\u00a4\5\60\31\2\u00a4\33\3\2\2\2\u00a5\u00a6\5B\"\2\u00a6")
        buf.write("\u00a7\7\34\2\2\u00a7\u00a8\5\64\33\2\u00a8\35\3\2\2\2")
        buf.write("\u00a9\u00aa\7\33\2\2\u00aa\u00ab\5 \21\2\u00ab\37\3\2")
        buf.write("\2\2\u00ac\u00b2\5$\23\2\u00ad\u00ae\5\"\22\2\u00ae\u00af")
        buf.write("\5$\23\2\u00af\u00b1\3\2\2\2\u00b0\u00ad\3\2\2\2\u00b1")
        buf.write("\u00b4\3\2\2\2\u00b2\u00b0\3\2\2\2\u00b2\u00b3\3\2\2\2")
        buf.write("\u00b3\u00ba\3\2\2\2\u00b4\u00b2\3\2\2\2\u00b5\u00b6\7")
        buf.write("\6\2\2\u00b6\u00b7\5 \21\2\u00b7\u00b8\7\7\2\2\u00b8\u00ba")
        buf.write("\3\2\2\2\u00b9\u00ac\3\2\2\2\u00b9\u00b5\3\2\2\2\u00ba")
        buf.write("!\3\2\2\2\u00bb\u00bc\t\2\2\2\u00bc#\3\2\2\2\u00bd\u00c2")
        buf.write("\5B\"\2\u00be\u00c2\5D#\2\u00bf\u00c0\7!\2\2\u00c0\u00c2")
        buf.write("\5$\23\2\u00c1\u00bd\3\2\2\2\u00c1\u00be\3\2\2\2\u00c1")
        buf.write("\u00bf\3\2\2\2\u00c2%\3\2\2\2\u00c3\u00c4\7\32\2\2\u00c4")
        buf.write("\'\3\2\2\2\u00c5\u00c6\7\30\2\2\u00c6)\3\2\2\2\u00c7\u00c8")
        buf.write("\7\31\2\2\u00c8\u00c9\5\64\33\2\u00c9+\3\2\2\2\u00ca\u00cb")
        buf.write("\7\27\2\2\u00cb\u00cc\5@!\2\u00cc-\3\2\2\2\u00cd\u00ce")
        buf.write("\7\26\2\2\u00ce\u00cf\5B\"\2\u00cf/\3\2\2\2\u00d0\u00d5")
        buf.write("\5\64\33\2\u00d1\u00d2\7\n\2\2\u00d2\u00d4\5\64\33\2\u00d3")
        buf.write("\u00d1\3\2\2\2\u00d4\u00d7\3\2\2\2\u00d5\u00d3\3\2\2\2")
        buf.write("\u00d5\u00d6\3\2\2\2\u00d6\61\3\2\2\2\u00d7\u00d5\3\2")
        buf.write("\2\2\u00d8\u00d9\5B\"\2\u00d9\63\3\2\2\2\u00da\u00df\5")
        buf.write("\66\34\2\u00db\u00dc\7,\2\2\u00dc\u00de\5\66\34\2\u00dd")
        buf.write("\u00db\3\2\2\2\u00de\u00e1\3\2\2\2\u00df\u00dd\3\2\2\2")
        buf.write("\u00df\u00e0\3\2\2\2\u00e0\65\3\2\2\2\u00e1\u00df\3\2")
        buf.write("\2\2\u00e2\u00e7\58\35\2\u00e3\u00e4\t\3\2\2\u00e4\u00e6")
        buf.write("\58\35\2\u00e5\u00e3\3\2\2\2\u00e6\u00e9\3\2\2\2\u00e7")
        buf.write("\u00e5\3\2\2\2\u00e7\u00e8\3\2\2\2\u00e8\67\3\2\2\2\u00e9")
        buf.write("\u00e7\3\2\2\2\u00ea\u010a\5D#\2\u00eb\u010a\5<\37\2\u00ec")
        buf.write("\u010a\5> \2\u00ed\u010a\5B\"\2\u00ee\u010a\5@!\2\u00ef")
        buf.write("\u00f0\7\6\2\2\u00f0\u00f1\5\64\33\2\u00f1\u00f2\7\7\2")
        buf.write("\2\u00f2\u010a\3\2\2\2\u00f3\u00f6\5D#\2\u00f4\u00f6\5")
        buf.write("B\"\2\u00f5\u00f3\3\2\2\2\u00f5\u00f4\3\2\2\2\u00f5\u00f6")
        buf.write("\3\2\2\2\u00f6\u00f7\3\2\2\2\u00f7\u00f8\7\17\2\2\u00f8")
        buf.write("\u00f9\5\64\33\2\u00f9\u00fa\7\20\2\2\u00fa\u010a\3\2")
        buf.write("\2\2\u00fb\u00fc\5:\36\2\u00fc\u00fd\5\64\33\2\u00fd\u010a")
        buf.write("\3\2\2\2\u00fe\u00ff\7!\2\2\u00ff\u010a\5\64\33\2\u0100")
        buf.write("\u0101\7\"\2\2\u0101\u010a\5\64\33\2\u0102\u0103\7&\2")
        buf.write("\2\u0103\u010a\5\64\33\2\u0104\u0105\5> \2\u0105\u0106")
        buf.write("\7\4\2\2\u0106\u0107\3\2\2\2\u0107\u0108\5\64\33\2\u0108")
        buf.write("\u010a\3\2\2\2\u0109\u00ea\3\2\2\2\u0109\u00eb\3\2\2\2")
        buf.write("\u0109\u00ec\3\2\2\2\u0109\u00ed\3\2\2\2\u0109\u00ee\3")
        buf.write("\2\2\2\u0109\u00ef\3\2\2\2\u0109\u00f5\3\2\2\2\u0109\u00fb")
        buf.write("\3\2\2\2\u0109\u00fe\3\2\2\2\u0109\u0100\3\2\2\2\u0109")
        buf.write("\u0102\3\2\2\2\u0109\u0104\3\2\2\2\u010a9\3\2\2\2\u010b")
        buf.write("\u010d\t\4\2\2\u010c\u010b\3\2\2\2\u010c\u010d\3\2\2\2")
        buf.write("\u010d\u010e\3\2\2\2\u010e\u010f\7 \2\2\u010f;\3\2\2\2")
        buf.write("\u0110\u0111\7+\2\2\u0111=\3\2\2\2\u0112\u0113\7(\2\2")
        buf.write("\u0113?\3\2\2\2\u0114\u0115\7/\2\2\u0115A\3\2\2\2\u0116")
        buf.write("\u0117\7-\2\2\u0117C\3\2\2\2\u0118\u011a\7,\2\2\u0119")
        buf.write("\u0118\3\2\2\2\u0119\u011a\3\2\2\2\u011a\u011b\3\2\2\2")
        buf.write("\u011b\u011c\7.\2\2\u011cE\3\2\2\2\u011d\u011e\7)\2\2")
        buf.write("\u011eG\3\2\2\2\u011f\u0120\7*\2\2\u0120I\3\2\2\2\u0121")
        buf.write("\u0122\7\'\2\2\u0122K\3\2\2\2\32QX\\`cfjn\u0080\u0083")
        buf.write("\u0089\u008f\u0096\u009a\u00b2\u00b9\u00c1\u00d5\u00df")
        buf.write("\u00e7\u00f5\u0109\u010c\u0119")
        return buf.getvalue()


class asm8086Parser(Parser):
    grammarFileName = "asm8086.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [DFA(ds, i) for i, ds in enumerate(atn.decisionToState)]

    sharedContextCache = PredictionContextCache()

    literalNames = ["<INVALID>", "'!'", "':'", "'.'", "'('", "')'", "'eq'",
                    "'ne'", "','", "'*'", "'/'", "'mod'", "'and'", "'['",
                    "']'", "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>",
                    "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>",
                    "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>",
                    "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>",
                    "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>",
                    "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>",
                    "<INVALID>", "<INVALID>", "'$'"]

    symbolicNames = ["<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>",
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>",
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>",
                     "<INVALID>", "<INVALID>", "<INVALID>", "BYTE", "WORD",
                     "DWORD", "DSEG", "CSEG", "INCLUDE", "TITLE", "END",
                     "ORG", "ENDIF", "IF", "EQU", "DW", "DB", "DD", "PTR",
                     "NOT", "OFFSET", "RW", "RB", "RS", "LENGTH", "COMMENT",
                     "REGISTER", "OPCODE", "REP", "DOLLAR", "SIGN", "NAME",
                     "NUMBER", "STRING", "EOL", "WS"]

    RULE_prog = 0
    RULE_line = 1
    RULE_instruction = 2
    RULE_lbl = 3
    RULE_assemblerdirective = 4
    RULE_rw = 5
    RULE_rb = 6
    RULE_rs = 7
    RULE_cseg = 8
    RULE_dseg = 9
    RULE_dw = 10
    RULE_db = 11
    RULE_dd = 12
    RULE_equ = 13
    RULE_if_ = 14
    RULE_assemblerexpression = 15
    RULE_assemblerlogical = 16
    RULE_assemblerterm = 17
    RULE_endif_ = 18
    RULE_end = 19
    RULE_org = 20
    RULE_title = 21
    RULE_include_ = 22
    RULE_expressionlist = 23
    RULE_label = 24
    RULE_expression = 25
    RULE_multiplyingExpression = 26
    RULE_argument = 27
    RULE_ptr = 28
    RULE_dollar = 29
    RULE_register_ = 30
    RULE_string_ = 31
    RULE_name = 32
    RULE_number = 33
    RULE_opcode = 34
    RULE_rep = 35
    RULE_comment = 36

    ruleNames = ["prog", "line", "instruction", "lbl", "assemblerdirective",
                 "rw", "rb", "rs", "cseg", "dseg", "dw", "db", "dd", "equ",
                 "if_", "assemblerexpression", "assemblerlogical", "assemblerterm",
                 "endif_", "end", "org", "title", "include_", "expressionlist",
                 "label", "expression", "multiplyingExpression", "argument",
                 "ptr", "dollar", "register_", "string_", "name", "number",
                 "opcode", "rep", "comment"]

    EOF = Token.EOF
    T__0 = 1
    T__1 = 2
    T__2 = 3
    T__3 = 4
    T__4 = 5
    T__5 = 6
    T__6 = 7
    T__7 = 8
    T__8 = 9
    T__9 = 10
    T__10 = 11
    T__11 = 12
    T__12 = 13
    T__13 = 14
    BYTE = 15
    WORD = 16
    DWORD = 17
    DSEG = 18
    CSEG = 19
    INCLUDE = 20
    TITLE = 21
    END = 22
    ORG = 23
    ENDIF = 24
    IF = 25
    EQU = 26
    DW = 27
    DB = 28
    DD = 29
    PTR = 30
    NOT = 31
    OFFSET = 32
    RW = 33
    RB = 34
    RS = 35
    LENGTH = 36
    COMMENT = 37
    REGISTER = 38
    OPCODE = 39
    REP = 40
    DOLLAR = 41
    SIGN = 42
    NAME = 43
    NUMBER = 44
    STRING = 45
    EOL = 46
    WS = 47

    def __init__(self, input: TokenStream, output: TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.9.2")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None

    class ProgContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def line(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(asm8086Parser.LineContext)
            else:
                return self.getTypedRuleContext(asm8086Parser.LineContext, i)

        def EOL(self, i: int = None):
            if i is None:
                return self.getTokens(asm8086Parser.EOL)
            else:
                return self.getToken(asm8086Parser.EOL, i)

        def getRuleIndex(self):
            return asm8086Parser.RULE_prog

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterProg"):
                listener.enterProg(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitProg"):
                listener.exitProg(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitProg"):
                return visitor.visitProg(self)
            else:
                return visitor.visitChildren(self)

    def prog(self):

        localctx = asm8086Parser.ProgContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_prog)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 86
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & (
                    (1 << asm8086Parser.T__0) | (1 << asm8086Parser.T__2) | (1 << asm8086Parser.DSEG) | (
                    1 << asm8086Parser.CSEG) | (1 << asm8086Parser.INCLUDE) | (1 << asm8086Parser.TITLE) | (
                            1 << asm8086Parser.END) | (1 << asm8086Parser.ORG) | (1 << asm8086Parser.ENDIF) | (
                            1 << asm8086Parser.IF) | (1 << asm8086Parser.DW) | (1 << asm8086Parser.DB) | (
                            1 << asm8086Parser.DD) | (1 << asm8086Parser.RW) | (1 << asm8086Parser.RB) | (
                            1 << asm8086Parser.RS) | (1 << asm8086Parser.COMMENT) | (1 << asm8086Parser.OPCODE) | (
                            1 << asm8086Parser.REP) | (1 << asm8086Parser.NAME) | (1 << asm8086Parser.EOL))) != 0):
                self.state = 74
                self.line()
                self.state = 79
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la == asm8086Parser.T__0:
                    self.state = 75
                    self.match(asm8086Parser.T__0)
                    self.state = 76
                    self.line()
                    self.state = 81
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 82
                self.match(asm8086Parser.EOL)
                self.state = 88
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class LineContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def lbl(self):
            return self.getTypedRuleContext(asm8086Parser.LblContext, 0)

        def assemblerdirective(self):
            return self.getTypedRuleContext(asm8086Parser.AssemblerdirectiveContext, 0)

        def instruction(self):
            return self.getTypedRuleContext(asm8086Parser.InstructionContext, 0)

        def comment(self):
            return self.getTypedRuleContext(asm8086Parser.CommentContext, 0)

        def getRuleIndex(self):
            return asm8086Parser.RULE_line

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterLine"):
                listener.enterLine(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitLine"):
                listener.exitLine(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitLine"):
                return visitor.visitLine(self)
            else:
                return visitor.visitChildren(self)

    def line(self):

        localctx = asm8086Parser.LineContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_line)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 90
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 2, self._ctx)
            if la_ == 1:
                self.state = 89
                self.lbl()

            self.state = 94
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [asm8086Parser.T__2, asm8086Parser.DSEG, asm8086Parser.CSEG, asm8086Parser.INCLUDE,
                         asm8086Parser.TITLE, asm8086Parser.END, asm8086Parser.ORG, asm8086Parser.ENDIF,
                         asm8086Parser.IF, asm8086Parser.DW, asm8086Parser.DB, asm8086Parser.DD, asm8086Parser.RW,
                         asm8086Parser.RB, asm8086Parser.RS, asm8086Parser.NAME]:
                self.state = 92
                self.assemblerdirective()
                pass
            elif token in [asm8086Parser.OPCODE, asm8086Parser.REP]:
                self.state = 93
                self.instruction()
                pass
            elif token in [asm8086Parser.T__0, asm8086Parser.COMMENT, asm8086Parser.EOL]:
                pass
            else:
                pass
            self.state = 97
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == asm8086Parser.COMMENT:
                self.state = 96
                self.comment()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class InstructionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def opcode(self):
            return self.getTypedRuleContext(asm8086Parser.OpcodeContext, 0)

        def rep(self):
            return self.getTypedRuleContext(asm8086Parser.RepContext, 0)

        def expressionlist(self):
            return self.getTypedRuleContext(asm8086Parser.ExpressionlistContext, 0)

        def getRuleIndex(self):
            return asm8086Parser.RULE_instruction

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterInstruction"):
                listener.enterInstruction(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitInstruction"):
                listener.exitInstruction(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitInstruction"):
                return visitor.visitInstruction(self)
            else:
                return visitor.visitChildren(self)

    def instruction(self):

        localctx = asm8086Parser.InstructionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_instruction)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 100
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == asm8086Parser.REP:
                self.state = 99
                self.rep()

            self.state = 102
            self.opcode()
            self.state = 104
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & (
                    (1 << asm8086Parser.T__3) | (1 << asm8086Parser.T__12) | (1 << asm8086Parser.BYTE) | (
                    1 << asm8086Parser.WORD) | (1 << asm8086Parser.DWORD) | (1 << asm8086Parser.PTR) | (
                            1 << asm8086Parser.NOT) | (1 << asm8086Parser.OFFSET) | (1 << asm8086Parser.LENGTH) | (
                            1 << asm8086Parser.REGISTER) | (1 << asm8086Parser.DOLLAR) | (1 << asm8086Parser.SIGN) | (
                            1 << asm8086Parser.NAME) | (1 << asm8086Parser.NUMBER) | (
                            1 << asm8086Parser.STRING))) != 0):
                self.state = 103
                self.expressionlist()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class LblContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def label(self):
            return self.getTypedRuleContext(asm8086Parser.LabelContext, 0)

        def getRuleIndex(self):
            return asm8086Parser.RULE_lbl

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterLbl"):
                listener.enterLbl(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitLbl"):
                listener.exitLbl(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitLbl"):
                return visitor.visitLbl(self)
            else:
                return visitor.visitChildren(self)

    def lbl(self):

        localctx = asm8086Parser.LblContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_lbl)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 106
            self.label()
            self.state = 108
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == asm8086Parser.T__1:
                self.state = 107
                self.match(asm8086Parser.T__1)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class AssemblerdirectiveContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def org(self):
            return self.getTypedRuleContext(asm8086Parser.OrgContext, 0)

        def end(self):
            return self.getTypedRuleContext(asm8086Parser.EndContext, 0)

        def if_(self):
            return self.getTypedRuleContext(asm8086Parser.If_Context, 0)

        def endif_(self):
            return self.getTypedRuleContext(asm8086Parser.Endif_Context, 0)

        def equ(self):
            return self.getTypedRuleContext(asm8086Parser.EquContext, 0)

        def db(self):
            return self.getTypedRuleContext(asm8086Parser.DbContext, 0)

        def dw(self):
            return self.getTypedRuleContext(asm8086Parser.DwContext, 0)

        def cseg(self):
            return self.getTypedRuleContext(asm8086Parser.CsegContext, 0)

        def dd(self):
            return self.getTypedRuleContext(asm8086Parser.DdContext, 0)

        def dseg(self):
            return self.getTypedRuleContext(asm8086Parser.DsegContext, 0)

        def title(self):
            return self.getTypedRuleContext(asm8086Parser.TitleContext, 0)

        def include_(self):
            return self.getTypedRuleContext(asm8086Parser.Include_Context, 0)

        def rw(self):
            return self.getTypedRuleContext(asm8086Parser.RwContext, 0)

        def rb(self):
            return self.getTypedRuleContext(asm8086Parser.RbContext, 0)

        def rs(self):
            return self.getTypedRuleContext(asm8086Parser.RsContext, 0)

        def getRuleIndex(self):
            return asm8086Parser.RULE_assemblerdirective

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterAssemblerdirective"):
                listener.enterAssemblerdirective(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitAssemblerdirective"):
                listener.exitAssemblerdirective(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitAssemblerdirective"):
                return visitor.visitAssemblerdirective(self)
            else:
                return visitor.visitChildren(self)

    def assemblerdirective(self):

        localctx = asm8086Parser.AssemblerdirectiveContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_assemblerdirective)
        try:
            self.state = 126
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 8, self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 110
                self.org()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 111
                self.end()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 112
                self.if_()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 113
                self.endif_()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 114
                self.equ()
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 115
                self.db()
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 116
                self.dw()
                pass

            elif la_ == 8:
                self.enterOuterAlt(localctx, 8)
                self.state = 117
                self.cseg()
                pass

            elif la_ == 9:
                self.enterOuterAlt(localctx, 9)
                self.state = 118
                self.dd()
                pass

            elif la_ == 10:
                self.enterOuterAlt(localctx, 10)
                self.state = 119
                self.dseg()
                pass

            elif la_ == 11:
                self.enterOuterAlt(localctx, 11)
                self.state = 120
                self.title()
                pass

            elif la_ == 12:
                self.enterOuterAlt(localctx, 12)
                self.state = 121
                self.include_()
                pass

            elif la_ == 13:
                self.enterOuterAlt(localctx, 13)
                self.state = 122
                self.rw()
                pass

            elif la_ == 14:
                self.enterOuterAlt(localctx, 14)
                self.state = 123
                self.rb()
                pass

            elif la_ == 15:
                self.enterOuterAlt(localctx, 15)
                self.state = 124
                self.rs()
                pass

            elif la_ == 16:
                self.enterOuterAlt(localctx, 16)
                self.state = 125
                self.match(asm8086Parser.T__2)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class RwContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def RW(self):
            return self.getToken(asm8086Parser.RW, 0)

        def expression(self):
            return self.getTypedRuleContext(asm8086Parser.ExpressionContext, 0)

        def name(self):
            return self.getTypedRuleContext(asm8086Parser.NameContext, 0)

        def getRuleIndex(self):
            return asm8086Parser.RULE_rw

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterRw"):
                listener.enterRw(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitRw"):
                listener.exitRw(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitRw"):
                return visitor.visitRw(self)
            else:
                return visitor.visitChildren(self)

    def rw(self):

        localctx = asm8086Parser.RwContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_rw)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 129
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == asm8086Parser.NAME:
                self.state = 128
                self.name()

            self.state = 131
            self.match(asm8086Parser.RW)
            self.state = 132
            self.expression()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class RbContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def RB(self):
            return self.getToken(asm8086Parser.RB, 0)

        def expression(self):
            return self.getTypedRuleContext(asm8086Parser.ExpressionContext, 0)

        def name(self):
            return self.getTypedRuleContext(asm8086Parser.NameContext, 0)

        def getRuleIndex(self):
            return asm8086Parser.RULE_rb

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterRb"):
                listener.enterRb(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitRb"):
                listener.exitRb(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitRb"):
                return visitor.visitRb(self)
            else:
                return visitor.visitChildren(self)

    def rb(self):

        localctx = asm8086Parser.RbContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_rb)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 135
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == asm8086Parser.NAME:
                self.state = 134
                self.name()

            self.state = 137
            self.match(asm8086Parser.RB)
            self.state = 138
            self.expression()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class RsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def RS(self):
            return self.getToken(asm8086Parser.RS, 0)

        def expression(self):
            return self.getTypedRuleContext(asm8086Parser.ExpressionContext, 0)

        def name(self):
            return self.getTypedRuleContext(asm8086Parser.NameContext, 0)

        def getRuleIndex(self):
            return asm8086Parser.RULE_rs

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterRs"):
                listener.enterRs(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitRs"):
                listener.exitRs(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitRs"):
                return visitor.visitRs(self)
            else:
                return visitor.visitChildren(self)

    def rs(self):

        localctx = asm8086Parser.RsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_rs)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 141
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == asm8086Parser.NAME:
                self.state = 140
                self.name()

            self.state = 143
            self.match(asm8086Parser.RS)
            self.state = 144
            self.expression()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class CsegContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def CSEG(self):
            return self.getToken(asm8086Parser.CSEG, 0)

        def expression(self):
            return self.getTypedRuleContext(asm8086Parser.ExpressionContext, 0)

        def getRuleIndex(self):
            return asm8086Parser.RULE_cseg

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterCseg"):
                listener.enterCseg(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitCseg"):
                listener.exitCseg(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitCseg"):
                return visitor.visitCseg(self)
            else:
                return visitor.visitChildren(self)

    def cseg(self):

        localctx = asm8086Parser.CsegContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_cseg)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 146
            self.match(asm8086Parser.CSEG)
            self.state = 148
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & (
                    (1 << asm8086Parser.T__3) | (1 << asm8086Parser.T__12) | (1 << asm8086Parser.BYTE) | (
                    1 << asm8086Parser.WORD) | (1 << asm8086Parser.DWORD) | (1 << asm8086Parser.PTR) | (
                            1 << asm8086Parser.NOT) | (1 << asm8086Parser.OFFSET) | (1 << asm8086Parser.LENGTH) | (
                            1 << asm8086Parser.REGISTER) | (1 << asm8086Parser.DOLLAR) | (1 << asm8086Parser.SIGN) | (
                            1 << asm8086Parser.NAME) | (1 << asm8086Parser.NUMBER) | (
                            1 << asm8086Parser.STRING))) != 0):
                self.state = 147
                self.expression()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class DsegContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DSEG(self):
            return self.getToken(asm8086Parser.DSEG, 0)

        def expression(self):
            return self.getTypedRuleContext(asm8086Parser.ExpressionContext, 0)

        def getRuleIndex(self):
            return asm8086Parser.RULE_dseg

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterDseg"):
                listener.enterDseg(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitDseg"):
                listener.exitDseg(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitDseg"):
                return visitor.visitDseg(self)
            else:
                return visitor.visitChildren(self)

    def dseg(self):

        localctx = asm8086Parser.DsegContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_dseg)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 150
            self.match(asm8086Parser.DSEG)
            self.state = 152
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & (
                    (1 << asm8086Parser.T__3) | (1 << asm8086Parser.T__12) | (1 << asm8086Parser.BYTE) | (
                    1 << asm8086Parser.WORD) | (1 << asm8086Parser.DWORD) | (1 << asm8086Parser.PTR) | (
                            1 << asm8086Parser.NOT) | (1 << asm8086Parser.OFFSET) | (1 << asm8086Parser.LENGTH) | (
                            1 << asm8086Parser.REGISTER) | (1 << asm8086Parser.DOLLAR) | (1 << asm8086Parser.SIGN) | (
                            1 << asm8086Parser.NAME) | (1 << asm8086Parser.NUMBER) | (
                            1 << asm8086Parser.STRING))) != 0):
                self.state = 151
                self.expression()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class DwContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DW(self):
            return self.getToken(asm8086Parser.DW, 0)

        def expressionlist(self):
            return self.getTypedRuleContext(asm8086Parser.ExpressionlistContext, 0)

        def getRuleIndex(self):
            return asm8086Parser.RULE_dw

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterDw"):
                listener.enterDw(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitDw"):
                listener.exitDw(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitDw"):
                return visitor.visitDw(self)
            else:
                return visitor.visitChildren(self)

    def dw(self):

        localctx = asm8086Parser.DwContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_dw)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 154
            self.match(asm8086Parser.DW)
            self.state = 155
            self.expressionlist()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class DbContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DB(self):
            return self.getToken(asm8086Parser.DB, 0)

        def expressionlist(self):
            return self.getTypedRuleContext(asm8086Parser.ExpressionlistContext, 0)

        def getRuleIndex(self):
            return asm8086Parser.RULE_db

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterDb"):
                listener.enterDb(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitDb"):
                listener.exitDb(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitDb"):
                return visitor.visitDb(self)
            else:
                return visitor.visitChildren(self)

    def db(self):

        localctx = asm8086Parser.DbContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_db)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 157
            self.match(asm8086Parser.DB)
            self.state = 158
            self.expressionlist()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class DdContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DD(self):
            return self.getToken(asm8086Parser.DD, 0)

        def expressionlist(self):
            return self.getTypedRuleContext(asm8086Parser.ExpressionlistContext, 0)

        def getRuleIndex(self):
            return asm8086Parser.RULE_dd

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterDd"):
                listener.enterDd(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitDd"):
                listener.exitDd(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitDd"):
                return visitor.visitDd(self)
            else:
                return visitor.visitChildren(self)

    def dd(self):

        localctx = asm8086Parser.DdContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_dd)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 160
            self.match(asm8086Parser.DD)
            self.state = 161
            self.expressionlist()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class EquContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def name(self):
            return self.getTypedRuleContext(asm8086Parser.NameContext, 0)

        def EQU(self):
            return self.getToken(asm8086Parser.EQU, 0)

        def expression(self):
            return self.getTypedRuleContext(asm8086Parser.ExpressionContext, 0)

        def getRuleIndex(self):
            return asm8086Parser.RULE_equ

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterEqu"):
                listener.enterEqu(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitEqu"):
                listener.exitEqu(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitEqu"):
                return visitor.visitEqu(self)
            else:
                return visitor.visitChildren(self)

    def equ(self):

        localctx = asm8086Parser.EquContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_equ)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 163
            self.name()
            self.state = 164
            self.match(asm8086Parser.EQU)
            self.state = 165
            self.expression()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class If_Context(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IF(self):
            return self.getToken(asm8086Parser.IF, 0)

        def assemblerexpression(self):
            return self.getTypedRuleContext(asm8086Parser.AssemblerexpressionContext, 0)

        def getRuleIndex(self):
            return asm8086Parser.RULE_if_

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterIf_"):
                listener.enterIf_(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitIf_"):
                listener.exitIf_(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitIf_"):
                return visitor.visitIf_(self)
            else:
                return visitor.visitChildren(self)

    def if_(self):

        localctx = asm8086Parser.If_Context(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_if_)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 167
            self.match(asm8086Parser.IF)
            self.state = 168
            self.assemblerexpression()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class AssemblerexpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def assemblerterm(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(asm8086Parser.AssemblertermContext)
            else:
                return self.getTypedRuleContext(asm8086Parser.AssemblertermContext, i)

        def assemblerlogical(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(asm8086Parser.AssemblerlogicalContext)
            else:
                return self.getTypedRuleContext(asm8086Parser.AssemblerlogicalContext, i)

        def assemblerexpression(self):
            return self.getTypedRuleContext(asm8086Parser.AssemblerexpressionContext, 0)

        def getRuleIndex(self):
            return asm8086Parser.RULE_assemblerexpression

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterAssemblerexpression"):
                listener.enterAssemblerexpression(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitAssemblerexpression"):
                listener.exitAssemblerexpression(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitAssemblerexpression"):
                return visitor.visitAssemblerexpression(self)
            else:
                return visitor.visitChildren(self)

    def assemblerexpression(self):

        localctx = asm8086Parser.AssemblerexpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_assemblerexpression)
        self._la = 0  # Token type
        try:
            self.state = 183
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [asm8086Parser.NOT, asm8086Parser.SIGN, asm8086Parser.NAME, asm8086Parser.NUMBER]:
                self.enterOuterAlt(localctx, 1)
                self.state = 170
                self.assemblerterm()
                self.state = 176
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la == asm8086Parser.T__5 or _la == asm8086Parser.T__6:
                    self.state = 171
                    self.assemblerlogical()
                    self.state = 172
                    self.assemblerterm()
                    self.state = 178
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                pass
            elif token in [asm8086Parser.T__3]:
                self.enterOuterAlt(localctx, 2)
                self.state = 179
                self.match(asm8086Parser.T__3)
                self.state = 180
                self.assemblerexpression()
                self.state = 181
                self.match(asm8086Parser.T__4)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class AssemblerlogicalContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def getRuleIndex(self):
            return asm8086Parser.RULE_assemblerlogical

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterAssemblerlogical"):
                listener.enterAssemblerlogical(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitAssemblerlogical"):
                listener.exitAssemblerlogical(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitAssemblerlogical"):
                return visitor.visitAssemblerlogical(self)
            else:
                return visitor.visitChildren(self)

    def assemblerlogical(self):

        localctx = asm8086Parser.AssemblerlogicalContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_assemblerlogical)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 185
            _la = self._input.LA(1)
            if not (_la == asm8086Parser.T__5 or _la == asm8086Parser.T__6):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class AssemblertermContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def name(self):
            return self.getTypedRuleContext(asm8086Parser.NameContext, 0)

        def number(self):
            return self.getTypedRuleContext(asm8086Parser.NumberContext, 0)

        def NOT(self):
            return self.getToken(asm8086Parser.NOT, 0)

        def assemblerterm(self):
            return self.getTypedRuleContext(asm8086Parser.AssemblertermContext, 0)

        def getRuleIndex(self):
            return asm8086Parser.RULE_assemblerterm

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterAssemblerterm"):
                listener.enterAssemblerterm(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitAssemblerterm"):
                listener.exitAssemblerterm(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitAssemblerterm"):
                return visitor.visitAssemblerterm(self)
            else:
                return visitor.visitChildren(self)

    def assemblerterm(self):

        localctx = asm8086Parser.AssemblertermContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_assemblerterm)
        try:
            self.state = 191
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [asm8086Parser.NAME]:
                self.enterOuterAlt(localctx, 1)
                self.state = 187
                self.name()
                pass
            elif token in [asm8086Parser.SIGN, asm8086Parser.NUMBER]:
                self.enterOuterAlt(localctx, 2)
                self.state = 188
                self.number()
                pass
            elif token in [asm8086Parser.NOT]:
                self.enterOuterAlt(localctx, 3)
                self.state = 189
                self.match(asm8086Parser.NOT)
                self.state = 190
                self.assemblerterm()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Endif_Context(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ENDIF(self):
            return self.getToken(asm8086Parser.ENDIF, 0)

        def getRuleIndex(self):
            return asm8086Parser.RULE_endif_

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterEndif_"):
                listener.enterEndif_(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitEndif_"):
                listener.exitEndif_(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitEndif_"):
                return visitor.visitEndif_(self)
            else:
                return visitor.visitChildren(self)

    def endif_(self):

        localctx = asm8086Parser.Endif_Context(self, self._ctx, self.state)
        self.enterRule(localctx, 36, self.RULE_endif_)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 193
            self.match(asm8086Parser.ENDIF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class EndContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def END(self):
            return self.getToken(asm8086Parser.END, 0)

        def getRuleIndex(self):
            return asm8086Parser.RULE_end

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterEnd"):
                listener.enterEnd(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitEnd"):
                listener.exitEnd(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitEnd"):
                return visitor.visitEnd(self)
            else:
                return visitor.visitChildren(self)

    def end(self):

        localctx = asm8086Parser.EndContext(self, self._ctx, self.state)
        self.enterRule(localctx, 38, self.RULE_end)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 195
            self.match(asm8086Parser.END)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class OrgContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ORG(self):
            return self.getToken(asm8086Parser.ORG, 0)

        def expression(self):
            return self.getTypedRuleContext(asm8086Parser.ExpressionContext, 0)

        def getRuleIndex(self):
            return asm8086Parser.RULE_org

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterOrg"):
                listener.enterOrg(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitOrg"):
                listener.exitOrg(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitOrg"):
                return visitor.visitOrg(self)
            else:
                return visitor.visitChildren(self)

    def org(self):

        localctx = asm8086Parser.OrgContext(self, self._ctx, self.state)
        self.enterRule(localctx, 40, self.RULE_org)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 197
            self.match(asm8086Parser.ORG)
            self.state = 198
            self.expression()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class TitleContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TITLE(self):
            return self.getToken(asm8086Parser.TITLE, 0)

        def string_(self):
            return self.getTypedRuleContext(asm8086Parser.String_Context, 0)

        def getRuleIndex(self):
            return asm8086Parser.RULE_title

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterTitle"):
                listener.enterTitle(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitTitle"):
                listener.exitTitle(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitTitle"):
                return visitor.visitTitle(self)
            else:
                return visitor.visitChildren(self)

    def title(self):

        localctx = asm8086Parser.TitleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 42, self.RULE_title)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 200
            self.match(asm8086Parser.TITLE)
            self.state = 201
            self.string_()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Include_Context(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INCLUDE(self):
            return self.getToken(asm8086Parser.INCLUDE, 0)

        def name(self):
            return self.getTypedRuleContext(asm8086Parser.NameContext, 0)

        def getRuleIndex(self):
            return asm8086Parser.RULE_include_

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterInclude_"):
                listener.enterInclude_(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitInclude_"):
                listener.exitInclude_(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitInclude_"):
                return visitor.visitInclude_(self)
            else:
                return visitor.visitChildren(self)

    def include_(self):

        localctx = asm8086Parser.Include_Context(self, self._ctx, self.state)
        self.enterRule(localctx, 44, self.RULE_include_)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 203
            self.match(asm8086Parser.INCLUDE)
            self.state = 204
            self.name()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ExpressionlistContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(asm8086Parser.ExpressionContext)
            else:
                return self.getTypedRuleContext(asm8086Parser.ExpressionContext, i)

        def getRuleIndex(self):
            return asm8086Parser.RULE_expressionlist

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterExpressionlist"):
                listener.enterExpressionlist(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitExpressionlist"):
                listener.exitExpressionlist(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitExpressionlist"):
                return visitor.visitExpressionlist(self)
            else:
                return visitor.visitChildren(self)

    def expressionlist(self):

        localctx = asm8086Parser.ExpressionlistContext(self, self._ctx, self.state)
        self.enterRule(localctx, 46, self.RULE_expressionlist)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 206
            self.expression()
            self.state = 211
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la == asm8086Parser.T__7:
                self.state = 207
                self.match(asm8086Parser.T__7)
                self.state = 208
                self.expression()
                self.state = 213
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class LabelContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def name(self):
            return self.getTypedRuleContext(asm8086Parser.NameContext, 0)

        def getRuleIndex(self):
            return asm8086Parser.RULE_label

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterLabel"):
                listener.enterLabel(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitLabel"):
                listener.exitLabel(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitLabel"):
                return visitor.visitLabel(self)
            else:
                return visitor.visitChildren(self)

    def label(self):

        localctx = asm8086Parser.LabelContext(self, self._ctx, self.state)
        self.enterRule(localctx, 48, self.RULE_label)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 214
            self.name()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def multiplyingExpression(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(asm8086Parser.MultiplyingExpressionContext)
            else:
                return self.getTypedRuleContext(asm8086Parser.MultiplyingExpressionContext, i)

        def SIGN(self, i: int = None):
            if i is None:
                return self.getTokens(asm8086Parser.SIGN)
            else:
                return self.getToken(asm8086Parser.SIGN, i)

        def getRuleIndex(self):
            return asm8086Parser.RULE_expression

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterExpression"):
                listener.enterExpression(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitExpression"):
                listener.exitExpression(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitExpression"):
                return visitor.visitExpression(self)
            else:
                return visitor.visitChildren(self)

    def expression(self):

        localctx = asm8086Parser.ExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 50, self.RULE_expression)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 216
            self.multiplyingExpression()
            self.state = 221
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input, 18, self._ctx)
            while _alt != 2 and _alt != ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 217
                    self.match(asm8086Parser.SIGN)
                    self.state = 218
                    self.multiplyingExpression()
                self.state = 223
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input, 18, self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class MultiplyingExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def argument(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(asm8086Parser.ArgumentContext)
            else:
                return self.getTypedRuleContext(asm8086Parser.ArgumentContext, i)

        def getRuleIndex(self):
            return asm8086Parser.RULE_multiplyingExpression

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterMultiplyingExpression"):
                listener.enterMultiplyingExpression(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitMultiplyingExpression"):
                listener.exitMultiplyingExpression(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitMultiplyingExpression"):
                return visitor.visitMultiplyingExpression(self)
            else:
                return visitor.visitChildren(self)

    def multiplyingExpression(self):

        localctx = asm8086Parser.MultiplyingExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 52, self.RULE_multiplyingExpression)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 224
            self.argument()
            self.state = 229
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input, 19, self._ctx)
            while _alt != 2 and _alt != ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 225
                    _la = self._input.LA(1)
                    if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & (
                            (1 << asm8086Parser.T__8) | (1 << asm8086Parser.T__9) | (1 << asm8086Parser.T__10) | (
                            1 << asm8086Parser.T__11))) != 0)):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()
                    self.state = 226
                    self.argument()
                self.state = 231
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input, 19, self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ArgumentContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def number(self):
            return self.getTypedRuleContext(asm8086Parser.NumberContext, 0)

        def dollar(self):
            return self.getTypedRuleContext(asm8086Parser.DollarContext, 0)

        def register_(self):
            return self.getTypedRuleContext(asm8086Parser.Register_Context, 0)

        def name(self):
            return self.getTypedRuleContext(asm8086Parser.NameContext, 0)

        def string_(self):
            return self.getTypedRuleContext(asm8086Parser.String_Context, 0)

        def expression(self):
            return self.getTypedRuleContext(asm8086Parser.ExpressionContext, 0)

        def ptr(self):
            return self.getTypedRuleContext(asm8086Parser.PtrContext, 0)

        def NOT(self):
            return self.getToken(asm8086Parser.NOT, 0)

        def OFFSET(self):
            return self.getToken(asm8086Parser.OFFSET, 0)

        def LENGTH(self):
            return self.getToken(asm8086Parser.LENGTH, 0)

        def getRuleIndex(self):
            return asm8086Parser.RULE_argument

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterArgument"):
                listener.enterArgument(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitArgument"):
                listener.exitArgument(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitArgument"):
                return visitor.visitArgument(self)
            else:
                return visitor.visitChildren(self)

    def argument(self):

        localctx = asm8086Parser.ArgumentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 54, self.RULE_argument)
        try:
            self.state = 263
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 21, self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 232
                self.number()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 233
                self.dollar()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 234
                self.register_()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 235
                self.name()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 236
                self.string_()
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 237
                self.match(asm8086Parser.T__3)
                self.state = 238
                self.expression()
                self.state = 239
                self.match(asm8086Parser.T__4)
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 243
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [asm8086Parser.SIGN, asm8086Parser.NUMBER]:
                    self.state = 241
                    self.number()
                    pass
                elif token in [asm8086Parser.NAME]:
                    self.state = 242
                    self.name()
                    pass
                elif token in [asm8086Parser.T__12]:
                    pass
                else:
                    pass
                self.state = 245
                self.match(asm8086Parser.T__12)
                self.state = 246
                self.expression()
                self.state = 247
                self.match(asm8086Parser.T__13)
                pass

            elif la_ == 8:
                self.enterOuterAlt(localctx, 8)
                self.state = 249
                self.ptr()
                self.state = 250
                self.expression()
                pass

            elif la_ == 9:
                self.enterOuterAlt(localctx, 9)
                self.state = 252
                self.match(asm8086Parser.NOT)
                self.state = 253
                self.expression()
                pass

            elif la_ == 10:
                self.enterOuterAlt(localctx, 10)
                self.state = 254
                self.match(asm8086Parser.OFFSET)
                self.state = 255
                self.expression()
                pass

            elif la_ == 11:
                self.enterOuterAlt(localctx, 11)
                self.state = 256
                self.match(asm8086Parser.LENGTH)
                self.state = 257
                self.expression()
                pass

            elif la_ == 12:
                self.enterOuterAlt(localctx, 12)
                self.state = 258
                self.register_()
                self.state = 259
                self.match(asm8086Parser.T__1)
                self.state = 261
                self.expression()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class PtrContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PTR(self):
            return self.getToken(asm8086Parser.PTR, 0)

        def BYTE(self):
            return self.getToken(asm8086Parser.BYTE, 0)

        def WORD(self):
            return self.getToken(asm8086Parser.WORD, 0)

        def DWORD(self):
            return self.getToken(asm8086Parser.DWORD, 0)

        def getRuleIndex(self):
            return asm8086Parser.RULE_ptr

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterPtr"):
                listener.enterPtr(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitPtr"):
                listener.exitPtr(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitPtr"):
                return visitor.visitPtr(self)
            else:
                return visitor.visitChildren(self)

    def ptr(self):

        localctx = asm8086Parser.PtrContext(self, self._ctx, self.state)
        self.enterRule(localctx, 56, self.RULE_ptr)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 266
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & (
                    (1 << asm8086Parser.BYTE) | (1 << asm8086Parser.WORD) | (1 << asm8086Parser.DWORD))) != 0):
                self.state = 265
                _la = self._input.LA(1)
                if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & (
                        (1 << asm8086Parser.BYTE) | (1 << asm8086Parser.WORD) | (1 << asm8086Parser.DWORD))) != 0)):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()

            self.state = 268
            self.match(asm8086Parser.PTR)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class DollarContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DOLLAR(self):
            return self.getToken(asm8086Parser.DOLLAR, 0)

        def getRuleIndex(self):
            return asm8086Parser.RULE_dollar

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterDollar"):
                listener.enterDollar(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitDollar"):
                listener.exitDollar(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitDollar"):
                return visitor.visitDollar(self)
            else:
                return visitor.visitChildren(self)

    def dollar(self):

        localctx = asm8086Parser.DollarContext(self, self._ctx, self.state)
        self.enterRule(localctx, 58, self.RULE_dollar)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 270
            self.match(asm8086Parser.DOLLAR)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Register_Context(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def REGISTER(self):
            return self.getToken(asm8086Parser.REGISTER, 0)

        def getRuleIndex(self):
            return asm8086Parser.RULE_register_

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterRegister_"):
                listener.enterRegister_(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitRegister_"):
                listener.exitRegister_(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitRegister_"):
                return visitor.visitRegister_(self)
            else:
                return visitor.visitChildren(self)

    def register_(self):

        localctx = asm8086Parser.Register_Context(self, self._ctx, self.state)
        self.enterRule(localctx, 60, self.RULE_register_)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 272
            self.match(asm8086Parser.REGISTER)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class String_Context(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def STRING(self):
            return self.getToken(asm8086Parser.STRING, 0)

        def getRuleIndex(self):
            return asm8086Parser.RULE_string_

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterString_"):
                listener.enterString_(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitString_"):
                listener.exitString_(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitString_"):
                return visitor.visitString_(self)
            else:
                return visitor.visitChildren(self)

    def string_(self):

        localctx = asm8086Parser.String_Context(self, self._ctx, self.state)
        self.enterRule(localctx, 62, self.RULE_string_)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 274
            self.match(asm8086Parser.STRING)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class NameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NAME(self):
            return self.getToken(asm8086Parser.NAME, 0)

        def getRuleIndex(self):
            return asm8086Parser.RULE_name

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterName"):
                listener.enterName(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitName"):
                listener.exitName(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitName"):
                return visitor.visitName(self)
            else:
                return visitor.visitChildren(self)

    def name(self):

        localctx = asm8086Parser.NameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 64, self.RULE_name)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 276
            self.match(asm8086Parser.NAME)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class NumberContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NUMBER(self):
            return self.getToken(asm8086Parser.NUMBER, 0)

        def SIGN(self):
            return self.getToken(asm8086Parser.SIGN, 0)

        def getRuleIndex(self):
            return asm8086Parser.RULE_number

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterNumber"):
                listener.enterNumber(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitNumber"):
                listener.exitNumber(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitNumber"):
                return visitor.visitNumber(self)
            else:
                return visitor.visitChildren(self)

    def number(self):

        localctx = asm8086Parser.NumberContext(self, self._ctx, self.state)
        self.enterRule(localctx, 66, self.RULE_number)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 279
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == asm8086Parser.SIGN:
                self.state = 278
                self.match(asm8086Parser.SIGN)

            self.state = 281
            self.match(asm8086Parser.NUMBER)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class OpcodeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OPCODE(self):
            return self.getToken(asm8086Parser.OPCODE, 0)

        def getRuleIndex(self):
            return asm8086Parser.RULE_opcode

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterOpcode"):
                listener.enterOpcode(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitOpcode"):
                listener.exitOpcode(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitOpcode"):
                return visitor.visitOpcode(self)
            else:
                return visitor.visitChildren(self)

    def opcode(self):

        localctx = asm8086Parser.OpcodeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 68, self.RULE_opcode)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 283
            self.match(asm8086Parser.OPCODE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class RepContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def REP(self):
            return self.getToken(asm8086Parser.REP, 0)

        def getRuleIndex(self):
            return asm8086Parser.RULE_rep

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterRep"):
                listener.enterRep(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitRep"):
                listener.exitRep(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitRep"):
                return visitor.visitRep(self)
            else:
                return visitor.visitChildren(self)

    def rep(self):

        localctx = asm8086Parser.RepContext(self, self._ctx, self.state)
        self.enterRule(localctx, 70, self.RULE_rep)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 285
            self.match(asm8086Parser.REP)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class CommentContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def COMMENT(self):
            return self.getToken(asm8086Parser.COMMENT, 0)

        def getRuleIndex(self):
            return asm8086Parser.RULE_comment

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterComment"):
                listener.enterComment(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitComment"):
                listener.exitComment(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitComment"):
                return visitor.visitComment(self)
            else:
                return visitor.visitChildren(self)

    def comment(self):

        localctx = asm8086Parser.CommentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 72, self.RULE_comment)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 287
            self.match(asm8086Parser.COMMENT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx
